# Talks I Like (and need to write about)

[Replacing functions with data - Bartosz Milewski - Haskell Love! 2020](https://www.youtube.com/watch?v=wppzFzzD4b8)

Bartosz shows the link between recursion and imperative functions in a very direct manner using a mechanical transformation (via CPS'ing and defunctionalization).

Probably the most concrete proof I've seen of the truth that recursion and imperative programs can represent each other. (Once you step past the simple case of tail recursion being iteration)

It also show cases the link between code and data in a nonLisp context.

## READING BACKLOG

- [Continuation Passing Style from AI Memo 349: Scheme - An Interpreter for extended lambda calculus](https://www.researchgate.net/profile/Gerald-Sussman-2/publication/227098423_Scheme_A_Interpreter_for_Extended_Lambda_Calculus/links/53d1413f0cf220632f392bf3/Scheme-A-Intended-Lambda-Calcrpreter-for-Exteulus.pdf)
- [Note: An more original but dirtier looking version of the paper from MIT](https://dspace.mit.edu/bitstream/handle/1721.1/5794/AIM-349.pdf)
- [Reynolds72 - Definitional interpreters for higher-order programming languages](https://surface.syr.edu/cgi/viewcontent.cgi?article=1012&context=lcsmith_other)
- [Danvy01 - Defunctionalization at Work](https://www.brics.dk/RS/01/23/BRICS-RS-01-23.pdf)
- [Reynolds93 - The Discoveries of Continuations](https://homepages.inf.ed.ac.uk/wadler/papee/reynolds-discors/papers-we-lovveries.pdf)

- [SSA is functional programming](https://www.cs.princeton.edu/~appel/papers/ssafun.pdf)

- [Compiler Design CS4410](https://course.ccs.neu.edu/cs4410sp20)

- [Andrew Appel - Modern Compiler Implementation in ML](https://www.cs.princeton.edu/~appel/modern/ml/)
