# Language related projects and resources on Github

Not a complete list. Just things I've stared on Github and some other stuff.

TODO annotate languages used.

## Mature Languages / Large Language Projects

|||
|-|-|
|[OCaml](https://github.com/ocaml/ocaml)|
|[ATS3 - ATS/Xanadu](https://github.com/githwxi/ATS-Xanadu)|
|[Agda](https://github.com/agda/agda)|
|[Futhark](https://github.com/diku-dk/futhark)|
|[Lean](https://github.com/leanprover/lean4)|
|[Idris](https://github.com/idris-lang/Idris2)|
|[Coq](https://github.com/coq/coq)|
|[Cayenne](https://github.com/csgordon/cayenne)|
|[Hamler](https://github.com/hamler-lang/hamler)|
|[PureScript](https://github.com/purescript/purescript)|
|[Dhall](https://github.com/dhall-lang/dhall-lang)|
|[Hackett](https://github.com/lexi-lambda/hackett)|

## Language Projects

### Tutorials / Razors

||||
|-|-|-|
|[Kaleidoscope - Haskell LLVM Tutorial by Stephen Diehl](https://github.com/sdiehl/kaleidoscope)|Haskell|LLVM|
|[A Tutorial Implementation of a Dependently Typed Lambda Calculus by Andres Löh, Conor McBride and Wouter Swierstra](https://www.andres-loeh.de/LambdaPi/)|Haskell|[Michael Peyton Jones's typing of the tutorial](https://github.com/michaelpj/lambda-pi)|
|[Cubiml - ML w/ subtyping and full type inference. Cubiml uses cubic biunification, a faster and simpler type inference algorithm based on Algebraic Subtyping](https://github.com/Storyyeller/cubiml-demo)|Rust|
|[POMPOM -  an attractive implementation of an extensional dependently typed language for functional programming and for people that want to have fun proving things](https://github.com/caotic123/PomPom-Language)|Haskell| "core is only 1000 lines aka the BASIC language of proof assistants"|

### Functional

|||
|-|-|
|[Aith - low level functional programming language with linear types, kind based staging / macros, levity polymorphism, and monadic region](https://github.com/Superstar64/aith)|Haskell, TODO A lot of resources on the README|
|[Poly - a WIP compiler](https://github.com/mb64/poly)|Haskell|
|[RustScript V2](https://github.com/mkhan45/RustScript2)|Ocaml|
|[SomewhatML sml-compiler](https://github.com/SomewhatML/sml-compiler)|Rust|
|[Sunchao Tiger ML impl](https://github.com/sunchao/tiger)|SML|

#### Dependently typed

|||
|-|-|
|[pie - From The Little Typer by Daniel P. Friedman and David Thrane Christiansen](https://github.com/the-little-typer/pie)|
|[pie-hs](https://github.com/david-christiansen/pie-hs)|
|[Idris EPIGRAM](https://github.com/JnxF/idris-epigram)|
|[epigram1](https://github.com/david-christiansen/epigram1)|
|[epigram2](https://github.com/mietek/epigram2)|
|[miniagda](https://github.com/andreasabel/miniagda)|

### Parallel

|||
|-|-|
|[Chapel - a Productive Parallel Programming Language](https://github.com/chapel-lang/chapel)|C++|

### Lisps

|||
|-|-|
|[Finkel - Haskell in S-expression.](https://github.com/finkel-lang/finkel)|Haskell|
|[Arret - Pure functional, strongly typed Lisp Like](https://github.com/etaoins/arret)|Rust|
|[Carp - A statically typed lisp, without a GC, for real-time applications.](https://github.com/carp-lang/Carp)|Haskell|

### EsoLang

| | |
|-|-|
|[bf-hs - Brainfuck interpretter written in Haskell](https://github.com/MorrowM/bf-hs)|
|[fckmaker - Esolang library in rust](https://github.com/uzkbwza/fckmaker)|Rust|

### λ-Calculi

| | |
|-|-|
|[A Formalization of Typed and Untyped λ-Calculi in Coq and Agda2](https://github.com/pi8027/lambda-calculus)|Coq,Agda|

### Visual Programming

| | |
|-|-|
|[Viskell - Haskell like experimental visaul programming environment](https://github.com/viskell/viskell)|Java|

### Prolog Derivatives

| | |
|-|-|
|[Aladadin, Jasmine, dialect of λProlog](https://github.com/KiJeong-Lim/ppap)|Haskell|
|[hasktrip - Datalog implementation in Haskell. Experimental proving ground for knowledge-base ideas.](https://github.com/seantalts/hasktrip)|Haskell|

### Imperative

| | |
|-|-|
|[legacy-cc - The earliest versions of the very first c compiler known to exist in the wild written by the late legend himself dmr.](https://github.com/mortdeus/legacy-cc)|
|[Redwood - A simple imperative programming language built to make small games.](https://github.com/sjsch/redwood)|Haskell|

### Concatenative

| | |
|-|-|
|[mlatu - mlatu is a declarative and concatenative programming language. It uses term rewriting as an evalutation model.](https://github.com/mlatu-lang/mlatu)|

## Intermediate Languages/Representation Projects

|||
|-|-|
|[calyx - an intermediate language and infrastructure for building compilers that generate custom hardware accelerators.](https://github.com/cucapra/calyx)|
|[firrtl - an intermediate representation (IR) for digital circuits designed as a platform for writing circuit-level transformations.](https://github.com/chipsalliance/firrtl)|Scala|
|[tinyjit - Haskell JIT Example](https://github.com/sdiehl/tinyjit)|Haskell|

## DSL Projects

||||
|-|-|-|
|[language-glsl - pretty printer](https://github.com/conal/language-glsl)|  
|[System-v - SystemVerilog subset DSL written in Idris](https://github.com/border-patrol/system-v)|
|[Dahlia -  programming language for designing hardware accelerators](https://github.com/cucapra/dahlia)|Scala|
|[Sequoia - an implementation of classical logic in a sequent calculus, embedded in intuitionistic logic](https://github.com/robrix/sequoia)|Haskell|
|[reanimate - Programatic Mathematical/2D vector drawing/animation DSL like 3b1b's manim library](https://github.com/reanimate/reanimate)|Haskell|
|[Kure - Kansas University Rewrite Engine for strategic rewriting.](https://github.com/ku-fpg/kure)|Haskell|ku-fpg, [The Kansas University Rewrite Engine: A Haskell-Embedded Strategic Programming Language with Custom Closed Universes. Neil Sculthorpe, Nicolas Frisby and Andy Gill. Journal of Functional Programming. Cambridge University Press, 24(4), pages 434-473, 2014.](https://dx.doi.org/10.1017/S0956796814000185)|
|[Octune - A DSL for creating 8-bit style music](https://github.com/fengctor/octune)|Haskell|
|[Lazyboy - An EDSL implemented in Haskell for programming the Nintendo Game Boy.](https://github.com/ix/lazyboy)|Haskell|
|[Hylogen - GLSL embedded in Haskell](https://github.com/sleexyz/hylogen)|Haskell|
|[necrophagy - A type-level, statically-verified Haskell embedded domain specific language (EDSL) for writing guitar tablature.](https://github.com/RiugaBachi/necrophagy)|Haskell|Typesafe|
|[ixshader - A shallow embedding of the OpenGL Shading Language in Haskell](https://github.com/schell/ixshader)|Haskell|
|[gristle - This is the spiritial successor to ixshader.](https://github.com/schell/gristle)|Haskell|
|[gelatin - EDSL for describing pictures and scenes.](https://github.com/schell/gelatin)|Haskell|
|[Haskino - framework for exploring EDSL concepts with the Arduino](https://github.com/ku-fpg/haskino)|Haskell|ku-fpg|
|[LambdaCube 3D](http://lambdacube3d.com/package-overview)||
|[LambdaCube-edsl - Older version of the LambdaCube3D](https://github.com/lambdacube3d/lambdacube-edsl)|
|[ImplicitCAD - A math-inspired CAD program in haskell. CSG, bevels, and shells; 2D & 3D geometry; 2D gcode generation...](https://github.com/Haskell-Things/ImplicitCAD)|Haskell|CAD|
|[blank-canvas - HTML5 Canvas bindings](https://github.com/ku-fpg/blank-canvas)|Haskell|ku-fpg|
|[static-canvas - HTML5 Canvas DSL for static non-interactive content](https://github.com/jeffreyrosenbluth/static-canvas)|

## Libraries / Reference Resources

||||
|-|-|-|
|[Type inference implementation using Algorithm W](https://github.com/bynect/algorithm-w)|OCaml|
|[lispkit - impl as described by book "FUNCTIONAL PROGRAMMING: Application and Implementation", by Peter Henderson, ISBN 0-13-331579-7"](https://github.com/carld/lispkit)|C|
|[nbe-edsl](https://github.com/nachivpn/nbe-edsl) - code accompanying the paper ["Practical Normalization by Evaluation for EDSLs"](https://homepages.inf.ed.ac.uk/slindley/papers/nbe-for-edsls-draft-may2021.pdf)|ESDL|
|[lfvm-stg - Map lazy functional language constructs to LLVM IR](https://github.com/jfaure/lfvm-stg)|Haskell|STG LLVM|
|[S-expresso](https://github.com/archambaultv/sexpresso)||
|[STGi - STG interpreter](https://github.com/quchen/stgi)|Haskell|STG|
|[Alex - A Lexical Analyser Generator](https://github.com/simonmar/alex)|Haskell|Lexer|
|[Happy - a parser generator for Haskell 98 (and later)](https://github.com/simonmar/happy)|Haskell|Parser Generator|
|[Arith - Alex and Happy tutorial](https://github.com/cse130-sp18/arith)|Alex,Happy|
|[GRIN - a compiler back-end for lazy and strict functional languages with whole program optimization support.](https://github.com/grin-compiler/grin)|Haskell|Backend|
|[llvm-hs - Haskell bindings for LLVM](https://github.com/llvm-hs/llvm-hs)|Haskell|LLVM|
|[unification-fd - generic functions for single-sorted first-order structural unification (think of programming in Prolog, or of the metavariables in type inference)](https://github.com/wrengr/unification-fd)|Haskell|Unification|
|[data-reify - Type-safe observable sharing](https://github.com/ku-fpg/data-reify)|Haskell|ku-fpg, Related to ["Type-Safe Observable Sharing in Haskell" by Andy Gill](http://www.ittc.ku.edu/~andygill/papers/reifyGraph.pdf)|
|[inversify - Parsing and printing in a single syntax description](https://github.com/brightly-salty/inversify)|Haskell|[Inversify uses the ideas from https://www.informatik.uni-marburg.de/~rendel/unparse/ to implement a featureful parser and pretty-printer from an invertible syntax description.](https://www.informatik.uni-marburg.de/~rendel/unparse/)
|[hobbits: A library for canonically representing terms with binding](https://github.com/eddywestbrook/hobbits)|Haskell|[Hobbits for Haskell: a library for higher-order encodings in functional programming languages](https://doi.org/10.1145/2034675.2034681)|


## Misc Libraries

### Testing

|||
|-|-|
|[should-not-typecheck](https://github.com/CRogers/should-not-typecheck)|

## Tools

### Python AST

|||
|-|-|
|[hpython - Haskell-based language tools for Python](https://github.com/qfpl/hpython)|

## Resources

||||
|-|-|-|
|[TaPL bits](https://github.com/andorp/TaPL)|
|[BorderPatrol resources on Resource Dependent EDSLs in Idris](https://github.com/border-patrol/resources)|
|[elaboration-zoo Haskell implementations for elaborating depedently typed languages](https://github.com/AndrasKovacs/elaboration-zoo)|
|[Calculating Correct Compilers supplementary material in Coq](https://github.com/pa-ba/calc-comp/commits/master)|Coq|Has stuff like call-by-name lambda calculus, call by need lambda calculus, call by value lc, etc|
|[dth - Examples of Dependently-typed programs in Haskell by Stephanie Weirich and others](https://github.com/sweirich/dth)|Haskell,Agda|
|[ghc-software-foundations - The Software Foundations books, in GHC](https://github.com/RyanGlScott/ghc-software-foundations)|Haskell|
|[stoeffel simple Haskell dsl examples](https://github.com/stoeffel/haskell-simple-dsl-examples)|

## Books

|||
|-|-|
|[Types and Progrramming Languages (TAPL) by Benjamin C. Pierce](https://www.cis.upenn.edu/~bcpierce/tapl/)|
|[Homotopy Type Theory](https://github.com/HoTT/HoTT)|Github for [HoTT Book](https://homotopytypetheory.org/book/)|
|["Dragon Book" - Compilers: Principles, Techniques, and Tools](http://web.archive.org/web/20211002212726/http://ce.sharif.edu/courses/94-95/1/ce414-2/resources/root/Text%20Books/Compiler%20Design/Alfred%20V.%20Aho,%20Monica%20S.%20Lam,%20Ravi%20Sethi,%20Jeffrey%20D.%20Ullman-Compilers%20-%20Principles,%20Techniques,%20and%20Tools-Pearson_Addison%20Wesley%20(2006).pdf)|[Official Page](https://suif.stanford.edu/dragonbook/)
|[Advanced Compiler Design and Implementation by Steven Muchnick](https://archive.org/details/advancedcompiler00much)|
|[Engineering a Compiler by Keith D. Cooper and Linda Torczon](http://web.archive.org/web/20211015174805/http://www.r-5.org/files/books/computers/compilers/writing/Keith_Cooper_Linda_Torczon-Engineering_a_Compiler-EN.pdf)|
|[Modern Compiler Implementation in ML by Andrew W. Appel](https://www.cs.princeton.edu/~appel/modern/ml/)|

Remarks by Colin on a few books:
```
colin — 07/05/2021
Appel's book is the most reasonable surface-level material that I know of
like most others books don't have an associated project with them
Appel's "modern compiler impl in ML/Java/C"
has the "Tiger" language
site:github.com "tiger compiler"
lots of unis teach this

a good book
that will make you want to get programming
is Muchnick's Advanced Compiler Design book
just don't take the pseudocode algorithms too seriously

I don't care much for "Engineering a Compiler"

Dragon book is good for generative parsing strategies
```

## Coursework

[A list of foundational Haskell papers](https://github.com/cohomolo-gy/haskell-resources).

[Haskell Reading Group](https://github.com/hackwithlambda/reading-group)

|||
|-|-|
|[Theorem Proving in Lean - Logic and Proof](https://github.com/leanprover/logic_and_proof)|[PDF](http://web.archive.org/web/20210823164937/https://leanprover.github.io/tutorial/tutorial.pdf) for [15-815 Interactive Theorem Proving](http://web.archive.org/web/20210124004200/https://leanprover.github.io/cmu-15815-s15/)|

### [Dragon Book]((http://web.archive.org/web/20211002212726/http://ce.sharif.edu/courses/94-95/1/ce414-2/resources/root/Text%20Books/Compiler%20Design/Alfred%20V.%20Aho,%20Monica%20S.%20Lam,%20Ravi%20Sethi,%20Jeffrey%20D.%20Ullman-Compilers%20-%20Principles,%20Techniques,%20and%20Tools-Pearson_Addison%20Wesley%20(2006).pdf))

|||
|-|-|
|[Dragon Book Selected lecture notes](https://suif.stanford.edu/dragonbook/lecture-notes.html)|
|[Stanford CS143 - Compilers](http://web.archive.org/web/20211024170111/https://web.stanford.edu/class/cs143/)|
|[Stanford CS243 - Advanced Compiling Techniques, Winter 2008, Prof. Monica Lam](http://web.archive.org/web/20210414205454/https://suif.stanford.edu/~courses/cs243/)
|[Stanford CS243 - Advanced Compiling Techniques, Winter 2006, Wei Li (Intel) Prof. Jeff Ullman](http://web.archive.org/web/20211020193235/http://infolab.stanford.edu/~ullman/dragon/w06/w06.html)|[MIT 6.035](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-035-computer-language-engineering-sma-5502-fall-2005/index.htm)|
|[Columbia COMS W4115: Programming Languages and Translators, Spring 2008, Prof. Alfred Aho](http://web.archive.org/web/20211019210931/http://www1.cs.columbia.edu/~aho/cs4115/)
|[Columbia COMS W4117: Compilers and Interpreters: Software Verification Tools, Fall 2007, Prof. Alfred Aho](http://web.archive.org/web/20080509103733/http://www1.cs.columbia.edu/~aho/cs4117/)


## Formal Semantics

|||
|-|-|
|[risc-vsemantics](https://github.com/mit-plv/riscv-semantics)||

## Coq/Proof Stuff/Type Theory

|||
|-|-|
|[proof-verifier by lylek](https://github.com/lylek/proof-verifier)|ND proof verifier in Haskell, not sure how complete|
|[A formalization of type theory in Coq](https://github.com/TheoWinterhalter/formal-type-theory)|Coq|
|[redtt - a core language for cartesian cubical type theory with extension types](https://github.com/RedPRL/redtt)|OCaml|
|[yacctt - Yet Another Cartesian Cubical Type Theory](https://github.com/mortberg/yacctt/)|Haskell|
|[cubicaltt - Experimental implementation of Cubical Type Theory](https://github.com/mortberg/cubicaltt)|Haskell|
|[datatt - A dependent type theory with user defined data types](https://github.com/mmcqd/datatt)|Ocaml|
|[Coq Library for SKI Combinatory Logic](https://github.com/markisus/coq-ski)|

### COQ MISC

|||
|-|-|
|[Tricks in Coq](https://github.com/tchajed/coq-tricks)|
